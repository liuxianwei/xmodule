1、深入理解Java内存模型（一）—— 基础
	1.1、并发编程模型：在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。
		在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。
		在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。
	
		Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。
	
	1.2、Java内存模型的抽象
		在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。
		Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。
	
	1.3、重排序，在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
		a. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
		b. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
		c. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
		以上a属于编译器层重排序，b属于处理器层重排序。
		
	1.4、处理器重排序与内存屏障指令，为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。
	
	1.5、happens-before
		从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。
		在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。
		与程序员密切相关的happens-before规则如下：
	
		a、程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
		b、监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
		c、volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。
		d、传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。
		
		注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！
		happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。
		
2、深入理解Java内存模型（二）—— 重排序
	2.1、数据依赖性，如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
		数据依赖分下列三种类型：读后写、写后读、写后写
		上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。
		前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。
		
		注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。
	2.2、as-if-serial(仿佛是串行的)语义，as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。
		为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。
		
		as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。
		
	JMM把happens- before要求禁止的重排序分为了下面两类：
	a、会改变程序执行结果的重排序。
	b、不会改变程序执行结果的重排序。
	JMM对这两种不同性质的重排序，采取了不同的策略：对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。

3、深入理解Java内存模型（三）—— 顺序一致性
	3.1、顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：
		a、一个线程中的所有操作必须按照程序的顺序来执行。
		b、（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。
	3.2、JMM对正确同步的多线程程序的内存一致性做了如下保证：
		如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）– 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。
	
		顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。
		顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。
		JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。
		
		在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写具有原子性。当JVM在这种处理器上运行时，会把一个64位long/ double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写将不具有原子性。
		注意，在JSR -133之前的旧内存模型中，一个64位long/ double型变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR -133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/ double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR -133中都必须具有原子性（即任意读操作必须要在单个读事务中执行）。
	
	顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。
	JMM和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。
	
4、深入理解Java内存模型（四）—— volatile
	4.1、当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。
		锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
		简而言之，volatile变量自身具有下列特性：
		可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
		原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。
		因此volatile适用于：对volatile变量的赋值应该是个不变式。
	4.2、volatile的写-读建立的happens before关系：volatile的写 happens before volatile的读，即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
		从JSR-133开始，volatile变量的写-读可以实现线程之间的通信(因为对volatile变量的写操作对所有线程来说是即时生效的写入，即对所有线程即时可见)。
		从内存语义的角度来说，volatile与锁有相同的效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。
	4.3、volatile写-读的内存语义
		volatile写的内存语义如下：
		a、当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
		b、当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
	4.4、volatile内存语义的实现
		当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
		当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
		当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。
		
5、深入理解Java内存模型（五）—— 锁
	5.1、锁的释放-获取建立的happens before 关系：同一个锁的释放 happens before 锁的获取
	5.2、锁释放和获取的内存语义
		当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
		当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。

6、深入理解Java内存模型（六）—— final
	6.1、写final域的重排序规则
		JMM禁止编译器把final域的写重排序到构造函数之外。也就是说构造函数return之前final域必定初始化(写)完毕了。
		顺便说一句：构造函数里面的普通成员变量的初始化可能被重排序到了构造函数之外了(意思是构造函数return之后某个普通成员变量才被执行初始化)，这也是双重检查锁(DCL)来实现单例模式的不可靠性所在(new一个对象的时候可能在return该对象引用之后对象的某个普通成员变量还未被初始化(被重排序了))
	6.2、读final域的重排序规则
		在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作。也就是说读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。
		初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。
	6.3、如果final域是引用类型
		对于final域为引用类型的情况，写final域的重排序规则对编译器和处理器增加了如下约束：
		在构造函数内对一个final域为引用类型的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
		例如：下面代码，根据前面所述，1与3之间肯定不能重排序，对于对于final域为引用类型的情况，写final域的重排序规则对编译器和处理器还约束了：2与3也不能重排序
		public class FinalReferenceExample {
			final int[] intArray;                     	//final是引用类型
			static FinalReferenceExample obj;
			
			public FinalReferenceExample () {        	//构造函数
			    intArray = new int[1];              	//1，对final域的写入
			    intArray[0] = 1;                   		//2，对final域对象的成员域的写入
			}
			
			public static void writerOne () {          	//写线程A执行
			    obj = new FinalReferenceExample ();  	//3，把被构造的对象的引用赋值给某个引用变量
			}
			
			public static void writerTwo () {          //写线程B执行
			    obj.intArray[0] = 2;                 //4
			}
			
			public static void reader () {              //读线程C执行
			    if (obj != null) {                    //5
			        int temp1 = obj.intArray[0];       //6
			    }
			}
		}
		
		JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。
		如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。
		
	6.4、final引用不能从构造函数内“逸出”
		在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中"逸出"。
		JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。
		
7、深入理解Java内存模型（七）—— 总结
	JMM对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。
	
	Java程序的内存可见性保证按程序类型可以分为下列三类：
	a、单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
	b、正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
	c、未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。